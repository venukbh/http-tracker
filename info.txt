Should we have seperate methods to access seperate events?
    Yes, that way we will execute same code (unwanted) for each action, there by reducing the load on the addon and browser. This will help better the performance and speed of data rendering.

    With all events in place, found that redirects will use same requestId but the urls will be different and the response codes will be different. However, when the onBeforeRedirect event is fired, the response will be a response for the previous request. So associate the response in this event to previous request and treat the request as a new request

Performace Enhancements:
    Change all querySelectors to getElementBy (https://blog.garstasio.com/you-dont-need-jquery/selectors/)
    var nodes = document.querySelectorAll( selector+':not([class="no-flip"])' );

// of inside for loop on an array gives key.
// in inside for loop on an array gives index.

https://developers.google.com/web/updates/2014/08/Easier-ArrayBuffer-String-conversion-with-the-Encoding-API
https://www.moesif.com/blog/technical/apirequest/How-We-Captured-AJAX-Requests-with-a-Chrome-Extension/
https://stackoverflow.com/questions/3149362/capture-key-press-or-keydown-event-on-div-element
https://css-tricks.com/almanac/selectors/e/empty/

For every request:
    onBeforeRequest:
        This event is triggered when a request is about to be made, and before headers are available. So no need to think of headers at this event.
        - Generates a unique requestId and captures url, requested method, request Body (if any)
    onBeforeSendHeaders:
        This event is triggered before sending any HTTP data, but after all HTTP headers are available. This is a good place to listen if you want to modify HTTP request headers. Request is about to occur and the initial headers have been prepared. The event is intended to allow extensions to add, modify, and delete request headers.
        - Capture all the headers here
    onSendHeaders:
        Fired just before a request is going to be sent to server after all modifications (if any) by other addons complete. It does not allow modifying or cancelling the request any more. This event is fired just before sending headers. If your extension or some other extension modified headers in onBeforeSendHeaders, you'll see the modified version here. This event is informational only.
        - Capture all the headers here as these will be the final versions to leave the browser
    onHeadersReceived:
        Fires each time that an HTTP(S) response header is received. Due to redirects and authentication requests this can happen multiple times per request. Fired when the HTTP response headers for a request are received. Use this event to modify HTTP response headers. To have the response headers passed into the listener, along with the rest of the request data, pass "responseHeaders" in the extraInfoSpec array.
        - Capture all the response headers here
    onAuthRequired:
        Fires when a request requires authentication of the user
    onBeforeRedirect:
        Fired when a server-initiated redirect is about to occur. Note that you can't pass "blocking" for this event, so you can't modify or cancel the request from this event: it's informational only.
    onResponseStarted:
        Fired when the first byte of the response body is received. This event is informational only. For HTTP requests, this means that the status line and response headers are available
    onCompleted:
        Fired when a request has completed.This event is informational only.
    onErrorOccurred:
        Fired when a request could not be processed due to an error: for example, a lack of Internet connectivity. The error is passed to the listener as the error property of the details object. Note that this event is not fired for HTTP errors (4XX or 5XX responses): these will go through the normal stages of a request, calling any event listeners, and setting details.statusCode to report the error. This event is informational only.

Cookies set in a request does not have expiry. They are just cookie name and values -- Recheck on this statement

comment-3:
    For a redirect or auth event, the response of this event corresponds to the previous request.
    So, get the requestIdEnhanced from the map and assign the response to the previous requestIdEnhanced
    If first time redirect for a requestId, then set redirectCount count to 0
    Else, get the redirect count (how many times the redirect happened for this unique requestId)
    Finally in either case,
         increment the count by 1 and
         put in the redirectRequestIdCount map and
         update the requestIdEnhanced property with the redirect count
    Since this is not a new event captured, no need to return true


javascript basics:
------------------
Fetch: extensions using fetch cannot access headers. Only browser can handle
    var myHeaders = new Headers();
        var myInit = {
            method: 'GET',
            headers: myHeaders,
            mode: 'cors',
            cache: 'default'
        };
        var myRequest = new Request('https://www.test.com/', myInit);
        fetch(myRequest).then(function(response) {
            console.log(response);
        });

https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch

In JavaScript “0” equals to false.

Generating the zip file for review:
    zip -r archives/http-tracker-v2.1.6.zip . -x "\.*" -x "__MACOSX" -x info.txt -x LICENSE -x README.md -x screenshots/\* -x "*.zip" -x \*.DS_Store -x archives/\*

Links:
    Firefox:
        https://developer.mozilla.org/en-US/docs/Web/API
        https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/windows
        https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/webRequest

    Chrome:
        https://developer.chrome.com/extensions/windows
        https://developer.chrome.com/extensions/webRequest
        https://chromium.googlesource.com/chromium/src/+/master/extensions/common/api/web_request.json

pending:
--------
* The response payload (js or html) can be captured only on developer tools. So addons cannot display
* In the onHeadersReceived listener you can access the TLS properties of a request by calling getSecurityInfo(). To do this you must also pass "blocking" in the extraInfoSpec argument to the event's addListener(). You can read details of the TLS handshake, but can't modify them or override the browser's trust decisions.
* options page
    option to enable copy
    option to exclude urls by default before so that they can be shared across addon openings
    option to open in a new popup or tab
* Add manifest version in title bar

Test scenarios:
---------------
    Check if the addon is opened in single window instead of multiple windows upon addon icon click
    Check include pattern is working
    check exclude pattern is working
    check both include and exclude pattern are working together (always exclude takes precedence)
    check if delete complete cache is working
    check if delete selected event is working
    check if clear filter is working
    check if delete all filtered urls working
    check if selecting an entry is showing request headers pane (request details, headers, cookies, body), response headers pane
    check if while filter is on, backend requests are getting captured
    in firefox, for few actions, get response is also showing as error. eg : load stackoverflow account page
    check if redirects are showing exactly as they are showing in browser network tab (working fine in chrome, firefox-private, but not in firefox regular window)
    exclude patterns not working if ending with comma
    for urls of type "service worker", request is being captured but not the response in firefox

Features:
Single instance addon - no matter how many times you click on the addon, it always loads a single instance popup window or a single tab which gets activated on further clicks
Non blocking (async) monitoring of the browser traffic, there by not introducing additional delay to the actual request-response pair

To run JavaScript performance:
    https://jsperf.com/empty-vs-check

Flow:
domEvents.js:
    There are 3 ways to display the list of urls.
        1. Right after the add-on is loaded by start tracking the httpTracker.webEventConsumer requests
        2. When the search box input changes
        3. When ever the requestIdURL map changes


js, png, gif,html, svg, jpg,ico,css,assets,woff,otf,bam.nr-data.net,click,tealium, akam
https://secure-www.test.com/profile/sign_in.do?targetURL=/buy/shopping_bag.do

https://en.wikipedia.org/wiki/Don%27t_repeat_yourself
https://www.f5.com/c/cloud-2019/application-delivery-saas-solutions?utm_campaign=amer-sc_ateap&utm_medium=cpc&utm_source=google&utm_content=pg_textad_intent_p3_a2_k0_ad_0_&utm_term=owasp%20guidelines&gclid=CjwKCAjwjqT5BRAPEiwAJlBuBf21hDqHCGQZfix7W4sTgrnlw-eOksaqa3CSVODE4v2IaZJdCepUSRoCNsIQAvD_BwE

https://www.chromium.org/hsts



logging in js:
    https://stackify.com/javascript-logging-basic-tips/


https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_Resources
https://www.ecma-international.org/publications/standards/Standard.htm
https://www.ecma-international.org/ecma-262/11.0/index.html#sec-properties-of-the-array-constructor
https://tc39.es/ecma262/
https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/


All methods "getElementsBy*" return a live collection. Such collections always reflect the current state of the document and “auto-update” when it changes.
https://javascript.info/searching-elements-dom


https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts : these are used to run scripts in the background


https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Anatomy_of_a_WebExtension#Background_scripts : Background scripts are loaded as soon as the extension is loaded and stay loaded until the extension is disabled or uninstalled